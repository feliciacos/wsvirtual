import React, { useEffect, useMemo, useRef, useLayoutEffect, useState } from "react";
import usePageZoom from "../../hooks/usePageZoom";
import Zone from "./Zone";
import HoverPreview from "./HoverPreview";
import SearchModal from "./SearchModal";
import DeckBox from "./DeckBox";
import CardView from "./CardView";
import { Card, CardInfo, ZoneKey, isStage, shuffle } from "../../utils/cards";
import { jsonUrlsCandidates, setKeyFromId, pickCode, codeAliases, splitId } from "../../utils/ids";
import { collectSetKeysFromIds, parseDeckTxt } from "../../utils/deckParse";
import { listDeckNames, loadDeck, saveDeck } from "../../utils/deckStore";
import { DND_MIME, DECK_MAX, STORAGE_KEY } from "../../config/constants";
import { createPortal } from "react-dom";

function setKeyFromCode(code: string): string {
  const p = splitId(code.toUpperCase());
  if (p) return p.setUnd;                // "AAA_BBB"
  const k = setKeyFromId(code);          // try our normal path
  if (k) return k;
  const m = code.toUpperCase().match(/^([A-Z0-9]{1,6})\/([A-Z0-9]{1,4})/);
  return m ? `${m[1]}_${m[2]}` : code.toUpperCase();
}

function idsFrom(zs: Record<string, Card[] | undefined>): string[] {
  const ids: string[] = [];
  for (const k in zs) {
    const arr = zs[k];
    if (Array.isArray(arr)) for (const c of arr) ids.push(c.id);
  }
  return ids;
}

export type LayoutMode = "vertical" | "horizontal";

const portalRoot = typeof window !== "undefined" ? document.body : null;
const makeUID = (() => { let n = 0; return () => `${Date.now().toString(36)}_${(n++).toString(36)}`; })();

type WSPlayfieldProps = {
  readOnly?: boolean;
  externalZones?: Record<ZoneKey, Card[]> | null;
  onZonesChange?: (z: Record<ZoneKey, Card[]>) => void;
  layout: "vertical" | "horizontal";
  side: "left" | "right";
};

const setCardRot = (
  z: ZoneKey, uid: string, rot: 0 | 90 | 180,
  setZonesFn: React.Dispatch<React.SetStateAction<Record<ZoneKey, Card[]>>>
) => {
  setZonesFn(prev => {
    const next = { ...prev, [z]: [...prev[z]] };
    const i = next[z].findIndex(c => c.uid === uid);
    if (i !== -1) next[z][i] = { ...next[z][i], rot };
    return next;
  });
};

function WSPlayfield({ readOnly = false, externalZones, onZonesChange, layout }: WSPlayfieldProps) {
  const pageZoom = usePageZoom();

  // measure untransformed content for horizontal rotation math
  const contentRef = React.useRef<HTMLDivElement>(null);
  const [natural, setNatural] = React.useState({ w: 0, h: 0 });

  useLayoutEffect(() => {
    const el = contentRef.current;
    if (!el) return;
    const update = () => setNatural({ w: el.offsetWidth, h: el.offsetHeight });
    update();
    const ro = new ResizeObserver(update);
    ro.observe(el);
    window.addEventListener("resize", update);
    return () => { ro.disconnect(); window.removeEventListener("resize", update); };
  }, [layout, externalZones, pageZoom]);

  // All cards from loaded sets
  const [catalog, setCatalog] = useState<Record<string, CardInfo>>({});
  const [setOrderIndex, setSetOrderIndex] = useState<Record<string, Record<string, number>>>({});
  const [loadingSets, setLoadingSets] = useState<Set<string>>(new Set());
  const [modalMsg, setModalMsg] = useState<string | null>(null);

  // Local zones (your board)
  const [zones, setZones] = useState<Record<ZoneKey, Card[]>>({
    CENTER_L: [], CENTER_C: [], CENTER_R: [],
    BACK_L: [], BACK_R: [],
    CLIMAX: [], LEVEL: [], CLOCK: [],
    STOCK: [], WAITING_ROOM: [], MEMORY: [],
    DECK: [], HAND: [],
    DECK_TEMP: [],
  });

  const viewZones = externalZones ?? zones;
  useEffect(() => { if (!readOnly && onZonesChange) onZonesChange(zones); }, [zones, readOnly, onZonesChange]);

  // ----- data loading helpers -----
  const loadSets = async (setKeys: string[]) => {
    const toLoad = setKeys.filter(k => k && !loadingSets.has(k));
    if (toLoad.length === 0) return;

    setLoadingSets(prev => new Set([...prev, ...toLoad]));
    const tryFetch = async (url: string) => {
      try { const r = await fetch(url); if (!r.ok) return null; return await r.json(); }
      catch { return null; }
    };

    const fetchSetAny = async (setKey: string) => {
      for (const cand of jsonUrlsCandidates(setKey)) {
        const data = await tryFetch(cand.url);
        if (data) return { lang: cand.lang, data };
      }
      return { lang: "EN" as const, data: null };
    };

    const results = await Promise.all(
      toLoad.map(async (setKey) => ({ setKey, ...(await fetchSetAny(setKey)) }))
    );

    const nextCatalog: Record<string, (CardInfo & { __lang?: "EN" | "JP" })> = {};
    const nextOrder: Record<string, Record<string, number>> = {};

    results.forEach(({ setKey, lang, data }) => {
      if (!data) return;
      const orderForSet: Record<string, number> = {};
      let idx = 0;

      if (Array.isArray(data)) {
        data.forEach((raw: any) => {
          const code = pickCode(raw);
          if (!code) return;
          const up = code.toUpperCase();
          const meta = { ...raw, __lang: lang } as any;
          idx += 1;
          orderForSet[up] = idx;
          nextCatalog[up] = meta;
          for (const a of codeAliases(up)) if (!nextCatalog[a]) nextCatalog[a] = meta;
        });
      } else if (data && typeof data === "object") {
        Object.entries<any>(data).forEach(([maybeCode, raw]) => {
          const code = (pickCode({ code: maybeCode, ...raw }) || maybeCode).toUpperCase();
          if (!code) return;
          const meta = { ...raw, __lang: lang } as any;
          idx += 1;
          orderForSet[code] = idx;
          nextCatalog[code] = meta;
          for (const a of codeAliases(code)) if (!nextCatalog[a]) nextCatalog[a] = meta;
        });
      }

      if (idx > 0) nextOrder[setKey] = orderForSet;
    });

    setCatalog((prev) => ({ ...prev, ...nextCatalog }));
    setSetOrderIndex((prev) => {
      const merged: typeof prev = { ...prev };
      for (const k of Object.keys(nextOrder)) merged[k] = nextOrder[k];
      return merged;
    });
    setLoadingSets((prev) => {
      const s = new Set(prev);
      for (const k of toLoad) s.delete(k);
      return s;
    });
  };

  // ensure metadata for visible cards
  useEffect(() => {
    const ids: string[] = [];
    (Object.keys(viewZones) as ZoneKey[]).forEach(z => viewZones[z].forEach(c => ids.push(c.id)));
    const keys = collectSetKeysFromIds(ids);
    if (keys.length) loadSets(keys);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [viewZones]);

  // simple LRU-ish trim of catalog by set
  const MAX_SETS_IN_MEMORY = 6;
  const trimTimer = React.useRef<number | null>(null);
  const lastUsedRef = React.useRef<Map<string, number>>(new Map());
  useEffect(() => {
    const inUseIds = idsFrom(viewZones);
    const keysInUse = new Set(collectSetKeysFromIds(inUseIds));
    if (keysInUse.size) {
      const now = Date.now();
      keysInUse.forEach(k => {
        const prevTs = lastUsedRef.current.get(k) ?? 0;
        if (now > prevTs) lastUsedRef.current.set(k, now);
      });
    }
    if (trimTimer.current) window.clearTimeout(trimTimer.current);
    trimTimer.current = window.setTimeout(() => {
      setCatalog((prev) => {
        const loadedSets = new Set<string>();
        for (const code in prev) loadedSets.add(setKeyFromCode(code));
        if (loadedSets.size <= MAX_SETS_IN_MEMORY) return prev;

        const evictable: Array<{ k: string; ts: number }> = [];
        loadedSets.forEach(k => { if (!keysInUse.has(k)) evictable.push({ k, ts: lastUsedRef.current.get(k) ?? 0 }); });
        evictable.sort((a, b) => a.ts - b.ts);

        const needToEvict = Math.max(0, loadedSets.size - MAX_SETS_IN_MEMORY);
        const toEvict = new Set(evictable.slice(0, needToEvict).map(e => e.k));
        if (toEvict.size === 0) return prev;

        const next: typeof prev = {};
        for (const code in prev) if (!toEvict.has(setKeyFromCode(code))) next[code] = prev[code];
        return next;
      });
    }, 400);
    return () => { if (trimTimer.current) { window.clearTimeout(trimTimer.current); trimTimer.current = null; } };
  }, [viewZones]);

  // persist local zones (your board)
  useEffect(() => {
    if (!readOnly) {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try { const p = JSON.parse(raw); if (p?.zones) setZones(p.zones); } catch { }
    }
  }, [readOnly]);
  useEffect(() => { if (!readOnly) localStorage.setItem(STORAGE_KEY, JSON.stringify({ zones })); }, [zones, readOnly]);

  // deck ops
  const [deckTxt, setDeckTxt] = useState("");
  const [errors, setErrors] = useState<string[]>([]);
  const [hoverCard, setHoverCard] = useState<Card | null>(null);
  const [searchZone, setSearchZone] = useState<ZoneKey | null>(null);
  const searchOpen = !!searchZone;

  const openSearch = (z: ZoneKey) => {
    const ids = (viewZones[z] ?? []).map(c => c.id);
    const keys = collectSetKeysFromIds(ids);
    if (keys.length) loadSets(keys);
    setSearchZone(z);
  };

  const importDeck = async () => {
    if (readOnly) return;
    const { entries, errors } = parseDeckTxt(deckTxt);
    setErrors(errors);
    let cards: Card[] = [];
    for (const e of entries) for (let i = 0; i < e.count; i++) cards.push({ uid: makeUID(), id: e.id });
    if (cards.length > DECK_MAX) {
      const overBy = cards.length - DECK_MAX;
      cards = cards.slice(0, DECK_MAX);
      setModalMsg(`Max reached, only added first ${DECK_MAX}${overBy > 0 ? ` (discarded ${overBy})` : ""}`);
    }
    const setKeys = Array.from(new Set(cards.map(c => setKeyFromId(c.id)).filter(Boolean))) as string[];
    await loadSets(setKeys);
    setZones(z => ({
      ...z,
      DECK: shuffle(cards),
      HAND: [], WAITING_ROOM: [], STOCK: [], CLOCK: [], LEVEL: [], MEMORY: [],
      CENTER_L: [], CENTER_C: [], CENTER_R: [], BACK_L: [], BACK_R: [], CLIMAX: [], DECK_TEMP: [],
    }));
  };

  const draw = (n = 1) => {
    if (readOnly) return;
    setZones(z => { const d = [...z.DECK], h = [...z.HAND]; for (let i = 0; i < n; i++) { const c = d.shift(); if (c) h.push(c); } return { ...z, DECK: d, HAND: h }; });
  };
  const shuffleDeck = () => { if (readOnly) return; setZones(z => ({ ...z, DECK: shuffle(z.DECK) })); };
  const resetDeck = () => {
    if (readOnly) return;
    setZones(z => ({
      ...z,
      DECK: [], HAND: [], WAITING_ROOM: [], STOCK: [], CLOCK: [], LEVEL: [], MEMORY: [],
      CENTER_L: [], CENTER_C: [], CENTER_R: [], BACK_L: [], BACK_R: [], CLIMAX: [], DECK_TEMP: [],
    }));
    setErrors([]);
  };

  const moveCardByUID = (from: ZoneKey, to: ZoneKey, uid: string, index?: number) => {
    if (readOnly) return;
    setZones((z) => {
      const src = [...z[from]];
      const i = src.findIndex((c) => c.uid === uid);
      if (i === -1) return z;

      let [card] = src.splice(i, 1);
      if (isStage(from) && !isStage(to)) card = { ...card, rot: 0 };

      if (from === to) {
        const insertAt = index ?? src.length;
        const adj = insertAt > i ? insertAt - 1 : insertAt;
        src.splice(adj, 0, card);
        return { ...z, [from]: src };
      }

      const dst = [...z[to]];
      if (to === "DECK" && index == null) {
        dst.splice(0, 0, card);              // place on top
        return { ...z, [from]: src, [to]: dst };
      } else {
        dst.splice(index ?? dst.length, 0, card);
        return { ...z, [from]: src, [to]: dst };
      }
    });
  };

  const onDragEnter = (e: React.DragEvent) => { if (readOnly) return; e.preventDefault(); e.dataTransfer.dropEffect = "move"; };
  const onDragOver = (e: React.DragEvent) => { if (readOnly) return; e.preventDefault(); e.dataTransfer.dropEffect = "move"; };
  const onDropZone = (to: ZoneKey) => (e: React.DragEvent) => {
    if (readOnly) return;
    e.preventDefault();
    setHoverCard(null);
    const raw = e.dataTransfer.getData(DND_MIME) || e.dataTransfer.getData("text/plain");
    if (!raw) return;
    try {
      const { uid, from } = JSON.parse(raw) as { uid: string; from: ZoneKey };
      moveCardByUID(from, to, uid);
    } catch { }
  };
  const onCardDragStart = (payload: { uid: string; from: ZoneKey }, e: React.DragEvent, visualEl: HTMLDivElement | null) => {
    const s = JSON.stringify(payload);
    e.dataTransfer.setData(DND_MIME, s);
    e.dataTransfer.setData("text/plain", s);
    e.dataTransfer.effectAllowed = "move";
    if (visualEl) e.dataTransfer.setDragImage(visualEl, 40, 56);
    const clear = () => setHoverCard(null);
    window.addEventListener("dragend", clear, { once: true });
  };

  // Global card sizing used by board + hand (80×112, 12px gap)
  const CARD_VARS: React.CSSProperties = {
    ["--card" as any]: "80px",
    ["--cardH" as any]: "112px",
    ["--gap" as any]: "12px",
  };

  // ---------- BoardCore: aligned panels, headerless Zones, right column stack ----------
  const BoardCore = () => {
    // one place to control the uniform panel height for the small panels
    const SMALL_PANEL_H = `calc(var(--cardH) + var(--gap) * 2 + 24px)`;
    // ⬇️ wider gaps so rotate buttons fit between cards
    const STAGE_GAP = `calc(var(--card) * 1.0)`;
    const SIDE_W = `calc(var(--card) * 1.8 + var(--gap) * 3)`;
    const SIDE_W_ROW1 = `calc(var(--card) * 1.8 + var(--gap) * 3)`; // keep your current size for CLIMAX/MEMORY row
    const SIDE_W_ROW2 = `calc(var(--card) * 1.6 + var(--gap) * 3)`; // a bit narrower for STOCK/DECK
    const DOUBLE_SMALL_PANEL_H = `calc((var(--cardH) + var(--gap) * 2 + 24px) * 2 + var(--gap))`;

    const Panel: React.FC<React.PropsWithChildren<{ title?: React.ReactNode; right?: React.ReactNode; minH?: string }>> =
      ({ title, right, minH = SMALL_PANEL_H, children }) => (
        <section className="rounded-2xl border border-white/10 bg-white/5 p-[var(--gap)]"
          style={{ minHeight: minH }}>
          {(title || right) && (
            <div className="flex items-center justify-between mb-2">
              <div className="text-xs uppercase tracking-wide text-white/70">{title}</div>
              {right}
            </div>
          )}
          {children}
        </section>
      );

    return (
      <main
        className="relative rounded-3xl border border-white/10 bg-gradient-to-b from-slate-800/40 to-slate-950/60"
        style={{ ...CARD_VARS, padding: "var(--gap)" }}
      >
        <div className="relative grid" style={{ gap: "var(--gap)" }}>

          {/* ===== Row 1: STOCK | CENTER STAGE (centered) | MEMORY ===== */}
          <div
            className="grid items-start"
            style={{ gridTemplateColumns: `${SIDE_W_ROW1} 1fr ${SIDE_W_ROW1}`, gap: "var(--gap)" }}
          >
            {/* STOCK (left) */}
            <Panel
              title={<>CLIMAX — {viewZones.CLIMAX.length}</>}
              right={!readOnly && (
                <button
                  className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                >Temp</button>
              )}
            >
              <Zone
                headerless
                z="CLIMAX"
                zones={zones}
                zonesToRender={viewZones}
                readOnly={readOnly}
                onDragEnter={onDragEnter}
                onDragOver={onDragOver}
                onDropZone={onDropZone}
                onDraw={draw}
                catalog={catalog}
                onCardDragStart={onCardDragStart}
                onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                setHoverCard={setHoverCard}
              />
            </Panel>

            {/* CENTER STAGE (center, width = 3 slots + spacing) */}
            <Panel
              title={<>CENTER STAGE — {viewZones.CENTER_L.length + viewZones.CENTER_C.length + viewZones.CENTER_R.length}</>}
              minH={SMALL_PANEL_H}
              right={
                // ⬅️ 2) Temporary button like “Search”
                !readOnly && (
                  <button
                    className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                    onClick={() => { }}
                    title="Temporary action"
                  >
                    Temp
                  </button>
                )
              }
            >
              <div
                className="flex items-start justify-center"
                style={{ gap: STAGE_GAP }}
              >
                <Zone
                  headerless
                  z="CENTER_L"
                  rows={1}
                  cols={1}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
                <Zone
                  headerless
                  z="CENTER_C"
                  rows={1}
                  cols={1}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
                <Zone
                  headerless
                  z="CENTER_R"
                  rows={1}
                  cols={1}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
              </div>
            </Panel>

            {/* MEMORY (right) */}
            <Panel
              title={<>MEMORY — {viewZones.MEMORY.length}</>}
              right={
                !readOnly && (
                  <button
                    className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                    onClick={() => openSearch("MEMORY")}
                  >Search</button>
                )
              }
            >
              <Zone
                headerless
                z="MEMORY"
                zones={zones}
                zonesToRender={viewZones}
                readOnly={readOnly}
                onDragEnter={onDragEnter}
                onDragOver={onDragOver}
                onDropZone={onDropZone}
                onDraw={draw}
                catalog={catalog}
                onCardDragStart={onCardDragStart}
                onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                setHoverCard={setHoverCard}
                onOpenSearch={openSearch}
              />
            </Panel>
          </div>

          {/* ===== Row 2: Stock (left) | BACK STAGE (centered) | RIGHT COLUMN: DECK, WAITING ROOM ===== */}
          <div className="grid items-start" style={{ gridTemplateColumns: "1fr auto 1fr", gap: "var(--gap)" }}>
            {/* Stock (left) */}
            <Panel
              title={<>STOCK — {viewZones.STOCK.length}</>}
              minH={SMALL_PANEL_H}
              right={!readOnly && (
                <button
                  className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                  onClick={() => openSearch("STOCK")}
                >
                  Search
                </button>
              )}
            >
              <Zone
                headerless
                z="STOCK"
                zones={zones}
                zonesToRender={viewZones}
                readOnly={readOnly}
                onDragEnter={onDragEnter}
                onDragOver={onDragOver}
                onDropZone={onDropZone}
                onDraw={draw}
                catalog={catalog}
                onCardDragStart={onCardDragStart}
                onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                setHoverCard={setHoverCard}
              />
            </Panel>

            {/* BACK STAGE (center) */}
            <Panel
              title={<>BACK STAGE — {viewZones.BACK_L.length + viewZones.BACK_R.length}</>}
              minH={SMALL_PANEL_H}
              right={
                !readOnly && (
                  <button
                    className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                    onClick={() => { }}
                    title="Temporary action"
                  >
                    Temp
                  </button>
                )
              }
            >
              <div className="flex items-start" style={{ gap: STAGE_GAP }}>
                <Zone
                  headerless
                  z="BACK_L"
                  rows={1}
                  cols={1}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
                <Zone
                  headerless
                  z="BACK_R"
                  rows={1}
                  cols={1}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
              </div>
            </Panel>

            {/* Right column: Deck (under Memory) then Waiting Room (match width) */}
            <div className="grid" style={{ gap: "var(--gap)" }}>
              {/* DECK panel */}
              <Panel
                title={<>DECK — {viewZones.DECK.length}</>}
                minH={SMALL_PANEL_H}
                right={
                  !readOnly && (
                    <button
                      className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                      onClick={() => openSearch("DECK")}
                    >
                      Search
                    </button>
                  )
                }
              >
                {/* Center the two deck slots inside the panel */}
                <div className="flex justify-center">
                  <div style={{ width: "calc(var(--card) * 2 + var(--gap) * 2)" }}>
                    <DeckBox
                      bare
                      zones={viewZones}
                      readOnly={readOnly}
                      catalog={catalog}
                      onDraw={draw}
                      onOpenSearch={openSearch}
                      onDragEnter={onDragEnter}
                      onDragOver={onDragOver}
                      onDropZone={onDropZone}
                      onCardDragStart={onCardDragStart}
                      onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                      setHoverCard={setHoverCard}
                    />
                  </div>
                </div>
              </Panel>

              {/* WAITING ROOM panel */}
              <Panel
                title={<>WAITING ROOM — {viewZones.WAITING_ROOM.length}</>}
                right={
                  !readOnly && (
                    <button
                      className="px-2 py-1 text-xs rounded-lg bg-white/10 hover:bg-white/20 border border-white/10"
                      onClick={() => openSearch("WAITING_ROOM")}
                    >Search</button>
                  )
                }
              >
                <Zone
                  headerless
                  z="WAITING_ROOM"
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                  onOpenSearch={openSearch}
                />
              </Panel>
            </div>
          </div>

          {/* ===== Row 3: Card Panel (left) | LEVEL (center) | CLOCK (right) ===== */}
          <div
            className="grid items-start"
            style={{
              gap: "var(--gap)",
              gridTemplateColumns: `${SIDE_W_ROW2} 1fr ${SIDE_W_ROW2}`,
            }}
          >
            {/* Left: Empty “Card panel” (same width as STOCK, same height as WR + Clock combined) */}
            <section
              className="rounded-2xl border border-white/10 bg-white/5 p-[var(--gap)]"
              // mirror the combined height of two small panels plus one gap
              style={{ minHeight: DOUBLE_SMALL_PANEL_H }}
            >
              {/* intentionally empty */}
            </section>

            {/* Center: LEVEL (same size as BACK STAGE panel) */}
            <section
              className="rounded-2xl border border-white/10 bg-white/5 p-[var(--gap)]"
              style={{ minHeight: SMALL_PANEL_H }}
            >
              <div className="flex items-center justify-between mb-2">
                <div className="text-xs uppercase tracking-wide text-white/70">
                  LEVEL — {viewZones.LEVEL.length}
                </div>
              </div>
              <div className="grid" style={{ gap: "var(--gap)" }}>
                <Zone
                  z="LEVEL"
                  rows={1}
                  cols={3}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
              </div>
            </section>

            {/* Right: CLOCK (under Waiting Room) */}
            <section
              className="rounded-2xl border border-white/10 bg-white/5 p-[var(--gap)]"
              style={{ minHeight: SMALL_PANEL_H }}
            >
              <div className="flex items-center justify-between mb-2">
                <div className="text-xs uppercase tracking-wide text-white/70">
                  CLOCK — {viewZones.CLOCK.length}
                </div>
              </div>
              <div className="grid">
                <Zone
                  z="CLOCK"
                  rows={1}
                  cols={6}
                  zones={zones}
                  zonesToRender={viewZones}
                  readOnly={readOnly}
                  onDragEnter={onDragEnter}
                  onDragOver={onDragOver}
                  onDropZone={onDropZone}
                  onDraw={draw}
                  catalog={catalog}
                  onCardDragStart={onCardDragStart}
                  onSetCardRot={(z0, uid, rot) => setCardRot(z0, uid, rot, setZones)}
                  setHoverCard={setHoverCard}
                />
              </div>
            </section>
          </div>
        </div>
      </main>
    );
  };


  // ---------- rotation wrapper ----------
  const rotationClass =
    layout === "horizontal"
      ? (externalZones ? "-rotate-90" : "rotate-90")
      : (externalZones ? "rotate-180" : "");

  const rot = externalZones ? -90 : 90;

  const board =
    layout === "horizontal" ? (
      <div
        className="relative inline-block"
        style={{ width: natural.h || 0, height: natural.w || 0 }}
      >
        <div className="absolute top-0 left-0 will-change-transform origin-top-left"
          style={{
            transform: rot === 90
              ? "rotate(90deg) translateY(-100%)"
              : "rotate(-90deg) translateX(-100%)",
          }}
        >
          <div ref={contentRef}>
            {BoardCore()}
          </div>
        </div>
      </div>
    ) : (
      <div className="relative inline-block">
        <div className={`transform-gpu ${externalZones ? "rotate-180" : ""} origin-center`}>
          <div ref={contentRef}>{BoardCore()}</div>
        </div>
      </div>
    );

  // width measuring for horizontal portals
  const [clusterWidth, setClusterWidth] = React.useState<number | null>(null);
  React.useLayoutEffect(() => {
    if (layout !== "horizontal") return;
    const el = document.getElementById("cluster-wrapper");
    if (!el) return;
    const update = () => setClusterWidth(el.getBoundingClientRect().width);
    const raf = requestAnimationFrame(update);
    const ro = new ResizeObserver(update);
    ro.observe(el);
    window.addEventListener("resize", update);
    return () => { cancelAnimationFrame(raf); ro.disconnect(); window.removeEventListener("resize", update); };
  }, [layout]);
  React.useEffect(() => { if (layout !== "horizontal") setClusterWidth(null); }, [layout]);

  // portals
  const handHost = typeof window !== "undefined" ? document.getElementById("hand-slot") : null;
  const importHost = typeof window !== "undefined" ? document.getElementById("import-slot") : null;

  const extrasWidth =
    layout === "horizontal"
      ? (clusterWidth ?? null)
      : null;

  const centerExtras = layout === "vertical" ? "mx-auto" : "";

  // Use the same size as board slots
  const HAND_CARD_VARS: React.CSSProperties = {
    ["--card" as any]: "80px",
    ["--cardH" as any]: "112px",
  };

  const HandSection = !readOnly && (
    <section
      className={`mt-3 box-border rounded-2xl bg-white/5 border border-white/10 ${centerExtras}`}
      style={{ ...CARD_VARS, width: extrasWidth ?? undefined, padding: "var(--gap)" }}
    >
      <h2 className="font-semibold mb-2">Hand — {zones.HAND.length}</h2>
      <div
        onDragEnter={!readOnly ? onDragEnter : undefined}
        onDragOver={!readOnly ? onDragOver : undefined}
        onDrop={!readOnly ? onDropZone("HAND") : undefined}
        className="flex flex-wrap border border-white/10 bg-black/20 rounded-xl overflow-x-hidden"
        style={{
          gap: "var(--gap)",
          minHeight: "calc(var(--cardH) + var(--gap))",
          padding: "var(--gap)",
        }}
      >
        {zones.HAND.length === 0 && (
          <div
            className="rounded-xl border-2 border-dashed border-white/20 bg-black/10"
            style={{ width: "var(--card)", height: "var(--cardH)" }}
          />
        )}
        {zones.HAND.map((c, i) => (
          <div key={c.uid} style={{ width: "var(--card)", height: "var(--cardH)" }}>
            <CardView
              card={c}
              zone="HAND"
              idx={i}
              readOnly={readOnly}
              catalog={catalog}
              onDragStart={onCardDragStart}
              onSetRot={(rot: 0 | 90 | 180) => setCardRot("HAND", c.uid, rot, setZones)}
              setHoverCard={setHoverCard}
            />
          </div>
        ))}
      </div>

      <div className="mt-2 flex gap-2">
        <button onClick={() => draw(1)} className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10">Draw 1</button>
        <button onClick={() => draw(5)} className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10">Draw 5</button>
        <button onClick={shuffleDeck} className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10">Shuffle Deck</button>
      </div>
    </section>
  );


  const ImportSection = !readOnly && (
    <div
      className={`box-border ${centerExtras}`}
      style={{ ...CARD_VARS, width: extrasWidth ?? undefined, paddingTop: "var(--gap)" }}
    >
      <ImportDeckBlock
        deckTxt={deckTxt}
        setDeckTxt={setDeckTxt}
        errors={errors}
        resetDeck={resetDeck}
        importDeck={importDeck}
      />
    </div>
  );

  const outerClass =
    layout === "horizontal"
      ? "flex-none px-0 py-4"
      : "max-w-7xl mx-auto px-3 py-3";

  const closeSearch = () => setSearchZone(null);

  return (
    <div className="relative inline-flex shrink-0 grow-0 basis-auto" style={CARD_VARS}>
      <div className={outerClass}>
        {board}
        {!readOnly && (
          layout === "horizontal" && handHost
            ? createPortal(HandSection, handHost)
            : HandSection
        )}
        {!readOnly && (
          layout === "horizontal" && importHost
            ? createPortal(ImportSection, importHost)
            : ImportSection
        )}
        <footer className="text-xs text-white/50 pt-2">Weiss Schwarz Virtual Tabletop, made by Feliciacos</footer>
      </div>

      <HoverPreview hoverCard={hoverCard} catalog={catalog} pageZoom={pageZoom} portalRoot={portalRoot} />

      <SearchModal
        open={searchOpen}
        zone={searchZone}
        readOnly={readOnly}
        cards={searchZone ? (viewZones[searchZone] ?? []) : []}
        catalog={catalog}
        onClose={closeSearch}
        onMoveSelected={({ from, to, uids }) => {
          if (readOnly) return;
          setZones(z => {
            const src = [...z[from]];
            const dst = [...z[to]];
            const moving: Card[] = [];
            for (const uid of uids) {
              const i = src.findIndex(c => c.uid === uid);
              if (i !== -1) { const [c] = src.splice(i, 1); moving.push(c); }
            }
            if (!moving.length) return z;

            if (to === "DECK") {
              return { ...z, [from]: src, [to]: [...moving, ...dst] }; // on TOP
            }
            return { ...z, [from]: src, [to]: [...dst, ...moving] };
          });
          closeSearch();
        }}
      />

      {!readOnly && modalMsg && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
          <div role="dialog" aria-modal="true" className="w-[22rem] rounded-2xl border border-white/10 bg-slate-900 text-white shadow-2xl p-4">
            <div className="text-base font-semibold mb-2">Import deck</div>
            <p className="text-sm text-white/90">{modalMsg}</p>
            <div className="mt-4 flex justify-end">
              <button onClick={() => setModalMsg(null)} className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10">OK</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/** Import Deck block */
function ImportDeckBlock({
  deckTxt, setDeckTxt, errors, resetDeck, importDeck,
}: {
  deckTxt: string; setDeckTxt: (s: string) => void; errors: string[];
  resetDeck: () => void; importDeck: () => void;
}) {
  const parseDeckName = (txt: string) => (txt.split(/\r?\n/, 1)[0] || "").trim() || "Untitled Deck";
  const [savedKey, setSavedKey] = useState(0);
  const savedNames = useMemo(() => listDeckNames(), [savedKey]);
  const [selectedName, setSelectedName] = useState<string>("");
  const autofilledRef = React.useRef(false);

  const handleImportSave = () => {
    if (!deckTxt.trim()) return;
    const name = saveDeck(parseDeckName(deckTxt), deckTxt);
    setSavedKey(k => k + 1);
    setSelectedName(name);
    importDeck();
  };
  const handleClear = () => { setDeckTxt(""); setSelectedName(""); resetDeck(); };

  useEffect(() => {
    if (autofilledRef.current) return;
    if (savedNames.length > 0) {
      const name = selectedName || savedNames[0];
      if (!selectedName) setSelectedName(name);
      const txt = loadDeck(name);
      if (txt && !deckTxt.trim()) { setDeckTxt(txt); autofilledRef.current = true; }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [savedNames]);

  useEffect(() => {
    if (!selectedName) return;
    const txt = loadDeck(selectedName);
    if (txt) setDeckTxt(txt);
  }, [selectedName, setDeckTxt]);

  return (
    <section className="mt-3 p-3 rounded-2xl bg-white/5 border border-white/10">
      <h2 className="font-semibold mb-2">Import Deck (.txt)</h2>
      <textarea
        value={deckTxt}
        onChange={(e) => setDeckTxt(e.target.value)}
        className="w-full h-40 p-2 rounded-xl bg-black/50 border border-white/10 outline-none font-mono text-xs"
        placeholder={`Paste EncoreDecks .txt here. Example:\nDAL/W79-TE10\t2\tHostile, Tohka\n(Top line is the deck name; headers like "Characters" are okay)`}
      />
      <div className="mt-2 flex flex-wrap gap-2 items-center">
        <button onClick={handleImportSave} className="px-3 py-1.5 rounded-xl bg-emerald-500/80 hover:bg-emerald-500 border border-white/10 text-black font-semibold">Import</button>
        <button onClick={handleClear} className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10">Clear</button>
        <select className="px-3 py-1.5 rounded-xl bg-black/40 border border-white/10 min-w-[16rem]" value={selectedName} onChange={(e) => setSelectedName(e.target.value)} title="Load a previously saved deck from cookies">
          {selectedName === "" && (<option value="" disabled>{savedNames.length ? "— Select a saved deck —" : "No saved decks"}</option>)}
          {savedNames.map((n: string) => <option key={n} value={n}>{n}</option>)}
        </select>
      </div>
      {errors.length > 0 && (
        <ul className="mt-2 text-sm text-red-300 list-disc list-inside space-y-1">
          {errors.map((e, i) => <li key={i}>{e}</li>)}
        </ul>
      )}
    </section>
  );
}

export default WSPlayfield;
